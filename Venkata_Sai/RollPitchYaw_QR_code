#!/usr/bin/env python
# -*- coding: utf-8 -*-


from __future__ import print_function
import time
from dronekit import connect, VehicleMode, mavutil
import argparse
from pyzbar.pyzbar import decode
import cv2
import numpy as np

# Argument Parsing
parser = argparse.ArgumentParser(description='QR-based full 3D alignment (ArduPilot SITL version)')
parser.add_argument('--connect', default='127.0.0.1:14550',
                    help='Vehicle connection target string.')
args = parser.parse_args()
connection_string = args.connect

# PID Controller
class PID:
    """Simple PID Controller."""
    def __init__(self, Kp, Ki, Kd, setpoint=0):
        self.Kp, self.Ki, self.Kd = Kp, Ki, Kd
        self.setpoint = setpoint
        self._last_error = 0
        self._integral = 0
        self._last_time = time.time()

    def update(self, current_value):
        current_time = time.time()
        dt = current_time - self._last_time
        if dt <= 0:
            return 0
        error = self.setpoint - current_value
        self._integral += error * dt
        derivative = (error - self._last_error) / dt
        output = (self.Kp * error) + (self.Ki * self._integral) + (self.Kd * derivative)
        self._last_error = error
        self._last_time = current_time
        return output


# DroneKit Functions
def connect_to_vehicle():
    print(f'Connecting to vehicle on: {connection_string}')
    vehicle = connect(connection_string, wait_ready=True, timeout=60)
    return vehicle

def arm_and_takeoff(vehicle, target_altitude):
    print("Performing pre-arm checks...")
    while not vehicle.is_armable:
        print(" Waiting for vehicle to initialise...")
        time.sleep(1)

    print("Arming motors...")
    vehicle.mode = VehicleMode("GUIDED")
    vehicle.armed = True

    while not vehicle.armed:
        print(" Waiting for arming...")
        time.sleep(1)

    print("Taking off...")
    vehicle.simple_takeoff(target_altitude)

    while True:
        altitude = vehicle.location.global_relative_frame.alt
        print(f" Altitude: {altitude:.2f}")
        if altitude >= target_altitude * 0.95:
            print(f"Reached target altitude: {target_altitude:.2f} meters")
            break
        time.sleep(1)

def send_velocity_command(vehicle, velocity_x, velocity_y, velocity_z):
    """
    Sends body-frame velocity commands (ArduPilot supported).
    X: forward (+), Y: right (+), Z: down (+)
    """
    msg = vehicle.message_factory.set_position_target_local_ned_encode(
        0, 0, 0,
        mavutil.mavlink.MAV_FRAME_BODY_NED,
        0b0000111111000111,  # enable velocity only
        0, 0, 0,
        velocity_x, velocity_y, velocity_z,
        0, 0, 0,
        0, 0)
    vehicle.send_mavlink(msg)
    vehicle.flush()

def condition_yaw(vehicle, yaw_rate_deg):
    """
    Rotate vehicle using MAV_CMD_CONDITION_YAW (ArduPilot's method).
    yaw_rate_deg: positive = clockwise, negative = counterclockwise
    """
    direction = 1 if yaw_rate_deg >= 0 else -1
    msg = vehicle.message_factory.command_long_encode(
        0, 0,
        mavutil.mavlink.MAV_CMD_CONDITION_YAW,
        0,
        0, abs(yaw_rate_deg), direction, 1, 0, 0, 0)
    vehicle.send_mavlink(msg)
    vehicle.flush()


# QR Alignment Loop
def qr_code_alignment(vehicle):
    print("\n--- Starting QR Code Alignment Loop ---")
    print("Press 'q' to land and exit.")

    video = cv2.VideoCapture(0)
    if not video.isOpened():
        print("Error: Could not open video feed.")
        return

    # PID Setup
    distance_pid = PID(Kp=0.0005, Ki=0, Kd=0.0001, setpoint=75000)  # target area (pixels)
    altitude_pid = PID(Kp=0.004, Ki=0.0001, Kd=0.001)
    roll_pid = PID(Kp=0.004, Ki=0.0001, Kd=0.001)
    yaw_pid = PID(Kp=0.004, Ki=0.0001, Kd=0.001)

    while True:
        ret, frame = video.read()
        if not ret:
            break

        height, width, _ = frame.shape
        cx, cy = width // 2, height // 2

        qr_codes = decode(frame)
        if qr_codes:
            qr = max(qr_codes, key=lambda obj: obj.rect.width * obj.rect.height)
            (x, y, w, h) = qr.rect
            qr_cx, qr_cy, qr_area = x + w // 2, y + h // 2, w * h

            # Compute errors
            error_x = cx - qr_cx
            error_y = cy - qr_cy

            # PID Outputs
            forward_speed = np.clip(distance_pid.update(qr_area), -0.5, 0.5)
            vertical_speed = -np.clip(altitude_pid.update(error_y), -0.4, 0.4)
            roll_speed = np.clip(roll_pid.update(-error_x), -0.4, 0.4)
            yaw_rate = np.clip(yaw_pid.update(-error_x), -0.5, 0.5)

            print(f"QR DETECTED | Fwd:{forward_speed:+.2f} | Roll:{roll_speed:+.2f} | Up:{vertical_speed:+.2f} | Yaw:{yaw_rate:+.2f}")

            # Send commands
            send_velocity_command(vehicle, forward_speed, roll_speed, -vertical_speed)
            condition_yaw(vehicle, np.degrees(yaw_rate))  # rad/s â†’ deg/s

            # Visualization
            pts = np.array(qr.polygon, np.int32).reshape((-1, 1, 2))
            cv2.polylines(frame, [pts], True, (0, 255, 0), 3)
            cv2.circle(frame, (qr_cx, qr_cy), 5, (0, 0, 255), -1)
            cv2.putText(frame, "QR DETECTED", (x, y - 10),
                        cv2.FONT_HERSHEY_PLAIN, 2, (0, 0, 255), 2)
        else:
            print("No QR code detected. Hovering...")
            send_velocity_command(vehicle, 0, 0, 0)

        # Draw center point
        cv2.circle(frame, (cx, cy), 5, (255, 0, 0), -1)
        cv2.imshow("Drone QR Alignment (SITL)", frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    print("Landing drone...")
    vehicle.mode = VehicleMode("LAND")
    time.sleep(5)
    video.release()
    cv2.destroyAllWindows()


# Main
if __name__ == '__main__':
    vehicle = None
    try:
        print("Step 1: Connecting to the drone...")
        vehicle = connect_to_vehicle()

        print("\nStep 2: Arming and taking off to 10m...")
        arm_and_takeoff(vehicle, 10)

        print("\nStep 3: Altitude reached. Starting QR alignment...")
        qr_code_alignment(vehicle)

    except Exception as e:
        print(f"\nError: {e}")

    finally:
        if vehicle:
            print("Setting mode to LAND and closing vehicle...")
            vehicle.mode = VehicleMode("LAND")
            time.sleep(3)
            vehicle.close()
        print("Script finished.")
